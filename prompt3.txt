import Reporter
import numpy as np

class r1085734:

    def __init__(self, seed=None):
        self.rng = np.random.default_rng(seed)
        self.reporter = Reporter.Reporter(self.__class__.__name__)
    
    def is_valid_solution(self, solution, weight_matrix):
        """
        Checks if a solution is valid (no edge has infinite weight).
        """
        for i in range(self.n):
            from_node = solution[i]
            # wrap around to form a cycle
            to_node = solution[(i + 1) % self.n]  
            if weight_matrix[from_node, to_node] == np.inf:
                return False
        return True
    

    def generate_initial_population(self, population_size):
        """
        Generates a population of valid TSP solutions.
        
        Each solution is a permutation of the node indices.
        Invalid solutions (with np.inf edges) are discarded.
        
        Parameters:
        - population_size (int): Number of solutions to generate.
        
        Returns:
        - population (np.ndarray): Array of shape (population_size, n) with each row a valid tour.
        """
        population = []
        attempts = 0
        max_attempts = population_size * 10  # prevent infinite loops

        while len(population) < population_size and attempts < max_attempts:
            candidate = self.rng.permutation(self.n)
            if self.is_valid_solution(candidate, self.distanceMatrix):
                population.append(candidate)
            attempts += 1

        if len(population) < population_size:
            raise ValueError("Could not generate enough valid solutions. Check the weight matrix.")

        return np.array(population)
    
    def fitness(self, solution):
        """
        Computes the total length of the tour represented by the solution.
        
        Parameters:
        - solution (np.ndarray): A permutation of node indices representing a tour.
        
        Returns:
        - total_distance (float): Sum of weights along the tour. Returns np.inf if any edge is invalid.
        """
        total_distance = 0.0
        for i in range(self.n):
            from_node = solution[i]
            to_node = solution[(i + 1) % self.n]  # wrap around to form a cycle
            weight = self.distanceMatrix[from_node, to_node]
            if weight == np.inf:
                return np.inf
            total_distance += weight
        return total_distance

    # The evolutionary algorithm's main loop
    def optimize(self, filename):	
        with open(filename) as file:
            self.distanceMatrix = np.loadtxt(file, delimiter=",")
            self.n = self.distanceMatrix.shape[0]

        # Your code here.
        yourConvergenceTestsHere = True
        while( yourConvergenceTestsHere ):
            meanObjective = 0.0
            bestObjective = 0.0
            bestSolution = np.array([1,2,3,4,5])

            # Your code here.

            # Call the reporter with:
            #  - the mean objective function value of the population
            #  - the best objective function value of the population
            #  - a 1D numpy array in the cycle notation containing the best solution 
            #    with city numbering starting from 0
            timeLeft = self.reporter.report(meanObjective, bestObjective, bestSolution)
            if timeLeft < 0:
                break

        # Your code here.
        return 0

def main():
    solver = r1085734()

This is the code I have written so far. Also include a test in the main method 
---------
import Reporter
import numpy as np

class r1085734:
    def __init__(self, seed=None):
        self.rng = np.random.default_rng(seed)
        self.reporter = Reporter.Reporter(self.__class__.__name__)

    def is_valid_solution(self, solution, weight_matrix):
        for i in range(self.n):
            from_node = solution[i]
            to_node = solution[(i + 1) % self.n]
            if weight_matrix[from_node, to_node] == np.inf:
                return False
        return True

    def generate_initial_population(self, population_size):
        population = []
        attempts = 0
        max_attempts = population_size * 10

        while len(population) < population_size and attempts < max_attempts:
            candidate = self.rng.permutation(self.n)
            if self.is_valid_solution(candidate, self.distanceMatrix):
                population.append(candidate)
            attempts += 1

        if len(population) < population_size:
            raise ValueError("Could not generate enough valid solutions. Check the weight matrix.")

        return np.array(population)

    def fitness(self, solution):
        total_distance = 0.0
        for i in range(self.n):
            from_node = solution[i]
            to_node = solution[(i + 1) % self.n]
            weight = self.distanceMatrix[from_node, to_node]
            if weight == np.inf:
                return np.inf
            total_distance += weight
        return total_distance

    def optimize(self, filename):
        with open(filename) as file:
            self.distanceMatrix = np.loadtxt(file, delimiter=",")
            self.n = self.distanceMatrix.shape[0]

        # Example placeholder loop
        yourConvergenceTestsHere = True
        while yourConvergenceTestsHere:
            population = self.generate_initial_population(10)
            fitness_values = np.array([self.fitness(ind) for ind in population])
            meanObjective = np.mean(fitness_values)
            best_idx = np.argmin(fitness_values)
            bestObjective = fitness_values[best_idx]
            bestSolution = population[best_idx]

            timeLeft = self.reporter.report(meanObjective, bestObjective, bestSolution)
            if timeLeft < 0:
                break

        return 0

def main():
    # Create a small test distance matrix
    test_matrix = np.array([
        [np.inf, 2, 9, 10],
        [1, np.inf, 6, 4],
        [15, 7, np.inf, 8],
        [6, 3, 12, np.inf]
    ])

    # Save to a temporary file
    filename = "test_matrix.csv"
    np.savetxt(filename, test_matrix, delimiter=",")

    # Run the solver
    solver = r1085734(seed=42)
    solver.optimize(filename)

if __name__ == "__main__":
    main()
-----
Call the generator of initial solutions in the optimize method and print each of them
together with their fitness score.