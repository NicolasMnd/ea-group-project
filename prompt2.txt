Also write a method to check for the fitness (total length) of a given solution
----

def fitness(self, solution):
    """
    Computes the total length of the tour represented by the solution.
    
    Parameters:
    - solution (np.ndarray): A permutation of node indices representing a tour.
    
    Returns:
    - total_distance (float): Sum of weights along the tour. Returns np.inf if any edge is invalid.
    """
    total_distance = 0.0
    for i in range(self.n):
        from_node = solution[i]
        to_node = solution[(i + 1) % self.n]  # wrap around to form a cycle
        weight = self.weight_matrix[from_node, to_node]
        if weight == np.inf:
            return np.inf
        total_distance += weight
    return total_distance